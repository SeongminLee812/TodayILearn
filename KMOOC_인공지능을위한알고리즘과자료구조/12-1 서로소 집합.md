# Disjoint-Set
- 집합들을 모아놓은 데이터 구조 $C=\{S_{1}, S_{2}, S_{3},..., S_{k}\}$
	- S1부터 Sk까지 전부 집합이고 디스조인트하다.
	- 디스 조인트 : 각각의 집합들의 공통으로 들어가는 데이터가 존재하지 않다
- 각 집합들은 대표되는 데이터 하나로 표현된다 ex) 이성민이 있는 셋

__Operation__
1. make-set : set을 만듬 (x 하나 - 대표값도 x)
2. union-set(x, y) : x가 속한 집합과 y과 속한 집합을 합집합을 해서 합침
3. find-set(x) : 주어진 x를 받아서 이 x가 포함된 set의 대표를 리턴
	1. if find-set(x)\=\=find-set(y)를 보기 위해서는 둘의 대표자가 같은 지 봄

__application__
- connected component문제에 적용
- ![[Pasted image 20221029151322.png]]
- 초기에는 그냥 각각이 스스로 대표자가 되는 집합 a부터 z까지 쭉 만들어 놓고
- 엣지의 양쪽 노드로 유니온 셋을 수행함
- ![[Pasted image 20221029151403.png]]
- union-set(a, b)는 (a,c)셋과 (b, d) 셋의 합집합이됨

__Implemantation__
![[Pasted image 20221029151511.png]]
1~25번 까지 나열해놓고 자신의 대표자를 쭉 적어놓음
- 내가 어떤 셋에 포함되는지 알아내는 것 -> 상수시간
- 유니온 셋을 한다면 대표자를 바꿔줘야함 (대표자가 2번인 집합과 대표자가 4번인 집합을 합한다면 4번인 집합을 다 2번으로 바꿔줘야함) -> 리니어 타임 소요(데이터 훑어보며 업데이트)

- 그러나 실제로는 트리형태의 자료구조를 사용함!
- 대표자를 루트에 놓고, 자식들이 대표자에 해당되는 집합에 포함
![[Pasted image 20221029151731.png]]
- 두 집합을 합집합을 한다면, ex) 2번과 4번을 합집합 한다면, 4번을 2의 자식으로 넣어줌
- ![[Pasted image 20221029151807.png]]
- 트리의 높이를 h라고 한다면 find-set의 경우 $O(h)$ ( 20의 대표를 알기 위해서는 20에서 출발해서 루트까지 도달)
- union-set => 두 값의 루트노드를 찾고, 합쳐줘야함 높이 만큼의 시간복잡도
- disjoint-set에서는 자식이 부모를 포인팅함
- ![[Pasted image 20221029151944.png]]

__구현__
- n개의 실수형에서 한다면
	- n개 짜리 어레이를 만들고 parent정보만 기록, 초기에는 자기 자신이 자신의 부모로 초기화
	- 나의 부모가 나 자신이라면 내가 대표자가 되는 것
- find-set 구현
- x가 스스로 parent가 아니면 따라서 올라감 -> $O(h)$
- ![[Pasted image 20221029152142.png]]
- union-set - find set 두번 수행 후 붙여줌 => $O(h)$
- ![[Pasted image 20221029152215.png]]
- union-set(1, 3)을 하면 3의 parent를 1로 바꿔줌
- ![[Pasted image 20221029152554.png]]
- union-set(3, 5)를 하는 경우 find-set(3)을 하면 1이 나오니까 5의 parent를 1로 바꿔줌
- ![[Pasted image 20221029152631.png]]
- union-set(6, 8)
	- ![[Pasted image 20221029152803.png]]
- union-set(4, 8)
	- find-set(4)의 결과와 find-set(8)의 결과를 합침
	- ![[Pasted image 20221029152703.png]]
![[Pasted image 20221029152910.png]]

- 복잡도는 노드의 개수가 아닌 트리의 높이에 비례함
- 트리를 붙일 때, 트리의 높이를 최소화하는 최적화를 수행해야함
- 이미 키가 큰 트리에 키가 상대적으로 작은 트리를 붙인다면 전체적인 높이가 증가하지 않는다.
- 높이가 높아지는 경우는? -> 두 트리의 높이가 똑같을 때.
- 디스조인트 셋의 worst case -> 항상 같은 높이의 높이를 계속 붙이는 시나리오

트리가 늘어날 때 파스칼 트라이앵글로 증가함
![[Pasted image 20221029153355.png]]
![[Pasted image 20221029153258.png]]
첫번째 노드는 파인드 셋이 1번만에 끝남.
그 다음레벨인 6개의 데이터는 1칸을 올라가야함
그 다음레벨인 15개의 데이터는 2칸을 올라가야함.
- ![[Pasted image 20221029153414.png]]
- h는 높이 k는 루트부터 자신까지 깊이

결론적으로 평균적인 find-set의 복잡도는 => $O(lg(N))$

