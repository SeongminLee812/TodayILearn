__Matrix Chain Multiplication__
- 많은 오퍼레이션들이 매트릭스 곱으로 표현됨
- 행렬 ABC 중에 AB를 먼저 곱하냐, BC를 먼저 곱하냐에 따라 계산량에 많은 차이가 남 -> 어떤 순서로 메트릭스 곱을 해야 최선일 지

- A행렬이 K x M의 2차원 행렬이고, B행렬이 M x N 행렬이라고 했을 때 아웃풋은 K x N 행렬이 나오고, 이 행렬을 곱하기 위해 필요한 계산량은 KMN만큼임

- ABCD 4개의 행렬이 있고, 이를 쭉 곱할 때, 아래와 같은 순서로 곱할 수 있음 -> 어떤 순서로 곱해야 계산량이 가장 적을까?
![[Pasted image 20221030195847.png]]
4개의 행렬이 주어졌을 때, 
![[Pasted image 20221030195918.png]]
순서대로 곱한다면
![[Pasted image 20221030195936.png]]
- ![[Pasted image 20221030195959.png]]
- 총 54,000만큼의 스칼라 곱이 필요
- ![[Pasted image 20221030200020.png]]
- 이렇게 곱하면 32,000만큼의 스칼라 곱 필요 -> 계산량이 훨신 더 적어짐

- A1 부터 An개까지의 N개의 행렬이 있다고 할 때, 괄호를 치는 방법은 N-1개의 다른 경우의 수가 있음
- ![[Pasted image 20221030200244.png]]
- A1부터 Ai까지 곱했을 때 어떤 모양의 행렬이 나오는 지 우리가 알고 있고, Ai+1부터 An까지 곱했을 때 어떤 모양이 나오는 지도 알고 있다. (이 둘의 모양을 알기 때문에 이 둘을 곱하는 데 드는 비용을 계산할 수 있다.)
- 결국 A1부터 Ai까지 곱하는 데 드는 최소비용과 Ai+1부터 An까지 드는 최소비용, sub-problem이 된다.
- 그러면 이제 i를 어디서 끊는 게 베스트인 지 알 수 있을 것이다.

- 재귀 호출로 구현
	- ![[Pasted image 20221030201102.png]]
- -> 피보나치와 똑같이 반복적으로 같은 과정을 수행하게 된다
- ![[Pasted image 20221030201344.png]]
- 다이나믹 프로그래밍 관점에서 최적의 곱셈 횟수를 미리 어딘가에 저장해 놓자!
- memoization 버전
	- ![[Pasted image 20221030201450.png]]
- 이 버전은 결국 $O(N^3)$의 성능이 나오게됨
	- for문을 돌면서 어디서 끊는 것이 베스트인지 계산을 하고, 메모 매트릭스가 $N^2$이고, 총 복잡도는 $O(N^3)$
	- \

__Bottom up 방식으로 구현__
- 아래 표를 채워 넣는 방법으로 진행
- i, j,에 Ai부터 Aj까지 갖고 있는 제일 좋은 솔루션을 채워 넣을 것
![[Pasted image 20221030201655.png]]
- 대각선 부분은 0임
- ![[Pasted image 20221030201819.png]]
- ![[Pasted image 20221030201913.png]]
- 
- 