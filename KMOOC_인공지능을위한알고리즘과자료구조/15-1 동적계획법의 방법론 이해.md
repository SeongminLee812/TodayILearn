- 동적계획법 (=다이나믹 프로그래밍)
- 피보나치 수열의 코드를 짜보면 재귀적으로 짤 수 있다
- ![[Pasted image 20221030184930.png]]
- n이 클 때 복잡도를 계산해보면 위와 같이 T(n)을 구하기 위해서 T(n-1)+T(n-2)를 해야한다. -> 실제로 피보나치 수 그 자체만큼 된다.
- 그 이유는 피보나치 50을 구하기 위해서는 피보나치 49와 48이 필요한데, 피보나치 49를 구하려면 또 48과 47이 필요하다. -> 피보나치 50을 수행하면 피보나치 45는 5번 수행되며 피보나치 40은 89번 수행되는 등 계속 반복되기 때문이다.
- 해결법 -> 피보나치 넘버가 계산이 되면, 다른 곳에 기록해놓는다.
- __memoization__ : 이 값을 메모해서 저장해 놓고 다시 재활용한다.
- ![[Pasted image 20221030185315.png]]
-  isFirstCall -> 메모리를 미리 할당
- 메모되어있는 경우에 그 값을 리턴하고, 그게 아니라면 재귀호출함
- Top down approach
	- 위에서 밑으로 내려오는 (피보나치 50을 풀기 위해서 그 sub-problem인 49, 48, 47, ...의 문제를 플어야함)
	- 대부분의 분할정복 알고리즘이 이런 방법을 채택하고 있음

- Bottom Up
	- 피보나치 첫번째 두번째 ~ 50까지 밑에서 위로 풀 수 있음
	- merge sort의 경우 
		- 문제를 적당한 사이즈로 쪼개 놓고 각각을 insertion sort를 통해서 정렬해놓고 merge만 하는 것
- 피보나치 수열의 Bottom up 방식 코드
	- ![[Pasted image 20221030185914.png]]

탑다운 방식을 풀 때, 반복적으로 수행하는 경우가 있을 때 이것을 저장해놓고 재활용해서 문제를 풀어나가는 방법을 **다이나믹 프로그래밍**이라고 함.
- 분할 정복과 차이점
	- 나눈 문제끼리 중복되는 것이 거의 없다.
	- 재활용할 여지가 없다.