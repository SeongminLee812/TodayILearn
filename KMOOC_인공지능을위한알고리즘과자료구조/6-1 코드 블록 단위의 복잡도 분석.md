
- 알고리즘이 n이 커졌을 때(문제의 사이즈) 알고리즘이 요구하는 런타임이 얼마나 증가하게 될까
- 큰 n에 대해 계산할 경우 복잡도를 잘 따져봐야함.

binary search의 복잡도는 $\Theta(lg n)$ 
lgn : 로그인데 로그의 밑이 2인 특수한 경우 (문제 사이즈 n을 두배로 증가시키더라도 계산량은 딱 1만큼만 증가)

Machine Instruction
- 더하기, 빼기, 곱하기, 나누기, 대소비교 등등 정해진 연산을 인스트럭션이라고 부르고, 인스트럭션들을 모아놓은 것을 인스트럭션 셋이라고 부름
- 컴파일 한다는 의미는 컴파일한 다음에 머신이 수행할 수 있는 인스트럭션 레벨로 표현하겠다는 의미
- 인스트럭션은 몇번의 사이클에 수행되는 지 정해져 있음
- CPU는 초당 몇 사이클을 도냐에 따라 1GHz, 2GHz라는 등으로 표현됨.
- 인스트럭션
	- ![[Pasted image 20221026161641.png]]
- 어셈블리 랭귀지
	- ![[Pasted image 20221026161654.png]]
- Java, C#, c++, python등은 굉장히 하이레벨 랭귀지임
- 하이레벨 -> 사람에 가깝다, 사람이 이해하기 좋다.
- 로우레벨 -> 인스트럭션, 어셈블리 랭귀지
- C 프로그래밍 랭귀지 -> 미드레벨

- 알고리즘을 분석할 때 사칙연산 등등의 오퍼레이션 들은 다 constant 타임에 수행될 수 있다.
	- 이것들은 머신 인스트럭션에 매핑되기 때문에, 정해진 숫자의 사이클안에 수행될 수 있다. -> linear한 시간에 수행될 수 있다.

__Blocks in Sequence__
![[스크린샷 2022-10-26 16.23.42.png]]


3블럭이 있다면, 가장 큰 값을 기준으로 이야기함
큰게 dominant한다고 표현함.
