# Minimum Spanning Tree
- Spanning Tree(신장트리) : 그래프의 모든 정점을 포함하는 트리
- Minimum Spanning Tree(MST, 최소신장트리) : Spanning Tree에서 사용된 간선(edge)들의 가중치 합이 최소인 트리
![[Pasted image 20221028094343.png]]
도시들이 있고, 도시들 사이에 거리가 엣지에 weight로 표현되어 있다고 했을 때, 모든 도시가 연결되도록(트리형태)로 이 그래프를 변환하고 싶은것. 도로 건설비를 최소화 하기 위해 edge들의 weight의 합이 최소화 되게끔 트리를 구성하는 알고리즘 문제임

- ![[Pasted image 20221028094506.png]]
- spanning tree : 모든 vertex들이 연결되는 트리
	- vertex가 16이라면 항상 엣지는 15개(이 15개의 엣지를 잘 고르는 문제임) -> 엣지들은 유니크하지는 않다
- spanning tree의 weight는 -> 선택한 엣지들의 weight의 합
- unweighted 그래프의 모든 minimum spanning트리의 weight는 -> 항상 vertex -1 이다.(트리에서의 엣지 개수는 vertex보다 하나 적기 때문)

__문제를 해결하기 위한 두가지 알고리즘__(모든 정점들을 가중치의 합이 최소가 되게 연결하는 문제)
1. 프림 알고리즘
2. 크루스칼 알고리즘
	 -> 둘 다 그리디 알고리즘임 
		 - 그리디 알고리즘 : 매순간마다 최선의 선택을 하는 탐욕적인 알고리즘(미래를 내다보지 않음)


## 1. Prim\`s algorithm
__아이디어__
- 어떤 그래프에서 vertex 하나만 선택했다면 그것은 하나만으로 미니멈 스패닝트리가 됨.
- 한가지 더 추가한다면 : v1으로부터 가장 가까운 엣지로 연결되어 있지만 weight가 가장 작은 vertex를 택해야함
- 이미 K개의 vertex로 이루어진 미니멈 스패닝 트리를 이미 가지고 있다고 가정했을 때, N개의 vertex를 포함하는 미니멈 스패닝 트리를 구성하는 것이 최종 목표 -> 하나씩 vertex들을 현재 미니멈 스패닝 트리에 포함시키면서 확장해나감
- 이를 위해서 K+1번째 다음 vertex를 어떤 방법으로 선택해야하는가가 문제임
- 따라서, 우리의 미니멈스패닝트리와 직접적으로 엣지 하나로 연결된 버텍스 가운데 웨이트가 가장 작은 것을 추가하는 알고리즘
- 현재 트리와 가장 가까운 버텍스를 하나씩 추가해나가는 방법
__최선의 선택인지?__
- 만약 노드 e와 연결하기 위해 하나의 엣지로 연결되고 가장 weight가 적은  e_k를 사용하지 않는다면, 어쨌든 다른 경로로 통해 e와 연결을 하는 e_tilde 엣지가 사용됨. 그러나 이 엣지는 처음 우리가 새로운 vertex를 연결하는 과정에서 최소의 weight를 가진 edge를 골랐기 때문에 e_tilde는 더 큰 weight를 갖게 된다.

- 어떠한 vertex에서 시작하던지 상관이 없다.
- 하나의 vertex를 설정하고, 그 vertex로부터 미니멈 스패팅 트리를 vertex를 하나씩 추가하는 형태로 진행
- 추가할때마다 현재 미니멈 스패닝 트리와 가장 적은weight를 가진 엣지를 선택하면서 N-1개의 엣지를 고를 때 까지 이를 반복 (N은 vertex개수)

### implementation
__1. Initialization__
**distance, visit, parent** : 3개의 배열을 관리
- **distance** : 미니멈 스패닝 트리로부터 특정 vertex까지의 거리
- **visit** : vertex가 이미 미니멈 스패팅 트리에 포함되었는 가 체크하는 플래그
- **parent** : 어떤 vertex가 미니멈 스패닝 트리에 포함될 때 어떤 노드와 직접적으로 연결되어 있는 가를 체크
- distance는 모두 무한대로 세팅을 함
- 루트노드인 시작하는 vertex의 distance는 0으로 설정
- 모든 vertex는 방문하지 않은 것으로 세팅하고 parent 포인터는 NULL 포인터 같은 것으로 설정

__2. iteration 반복__
1. unvisit vertex 중에 minimum spanning tree에 추가되지 않은 vertex중에 가장 distance가 작은 것 e_k를 고름(e_k로 연결되는 v_k+1)
2. 그 vertex를 우리 미니멈 스패닝 트리로 포함시킨 후, 새로운 vertex가 미니멈 스패닝 트리로 추가되었기 때문에 distance를 업데이트 해줌
- 종료 조건 : 모든 vertex가 visit되었거나(그렇다면 우리 MST는 전체 그래프를 커버하고 있는 것임)
	- 알고리즘이 더이상 진행되지 않는 데 vertex가 더이상 방문할 수 없는 거리가 무한대인 vertex가 남아있다는 것은 원래 그래프가 connected되지 않았다는 의미

__3. 예제__
![[Pasted image 20221028101553.png]]
- 앞에 F부분은 visit 플래그임
- 매 iteration마다 distance가 가장 작은 visit되지 않은 것
- 현재는 1번 vertex만 ditance가 0이기 때문에 방문, T로 바꿔줌
- ![[Pasted image 20221028101650.png]]
- 1번 vertex에 인접한 2, 4, 5 vertex를 업데이트 함
- 2, 4, 5의 parent를 1번으로 업데이트함(해당 vertex를 초대한 vertex)
	- (이 상황에서 2번이 visit된다는 의미는 1번 2번을 연결하는 엣지가 추가된다는 의미)
- 우리의 후보군 : 2, 4, 5 -> distance가 가장 작은 4번을 고름!
- ![[Pasted image 20221028101913.png]]
- 4번 방문 체크
- 4번에 인접한 2, 5, 7, 8의 거리를 업데이트
- 2번과의 거리를 봤을 때 1번과 연결하는 것 보다 4번과 연결하는 것이 **이득**이기 때문에 4번의 정보로 업데이트해준다(거리, parent)
- 5번은 원래 거리가 8인데 4랑 연결하면 11로 **손해**가됨
	- 5번은 업데이트 하지 않음
- 7, 8번은 처음 봤으므로 4번으로 업데이트 해줌
- 후보군 업데이트
- ![[Pasted image 20221028102133.png]]
- visit플래그가 F인 vertex 중에 distance가 가장 작은 -> 2번 선택
- ![[Pasted image 20221028102206.png]]
- 2번과 인접해있는 1, 4, 5, 6, 3을 봄(1, 4는 visit이니까 무시)
- 5, 6, 3을 보니 5번은 원래 4번과 연결했을 때보다 2번과 연결했을 때 더 짧아지니까 2번 기준으로 업데이트해줌
- 3, 6도 처음봤으니 업데이트 해줌
- 후보군 늘어남
- ![[Pasted image 20221028102340.png]]
- visit하지 않은 vertex 중 가장 distance가 작은 6번 방문
- iteration 반복
- 미니멈 스패닝 트리에 계속 하나씩 추가하면서 모든 vetex 추가될 때까지 반복하면 프림 알고리즘이 끝남.
- 방문되지 않는 vertex가 있는 데 그 거리가 무한대라면 애초부터 연결되지 않은 그래프임.
- -> 결과
- ![[Pasted image 20221028102507.png]]
- 트리를 구성하기 위해서는 parent를 보면 됨

__복잡도 분석__
- initialization 할 때, 배열 생성 시 $\Theta(|V|)$(vertex개수만큼)의 메모리, 런타임 소비
- 이후에 V-1번 iteration 반복, 그때마다 distance테이블을 쭉 스캔해야하기 때문에 그때 드는 비용 -> V만큼 개수 보면서 최소값 찾음($\Theta(|V|)$) -> 찾았으면 vertex로부터 연결된 다른 vertex들의 거리를 체크해야함. -> 그러기위해서 인접행렬을 쓴다면 $\Theta(|V|)$만큼 소비(한 row를 다 스캔) => 프림 알고리즘의 복잡도는 $\Theta(|V|^2)$ / 만약 인접 리스트를 쓴다면, vertex를 통해서 방문했을 때 엣지를 통해서 vertex들을 업데이트 하기 때문에 업데이트 횟수는 엣지의 개수를 넘지 않는다.
- $\Theta(|V|^{2}+|E|)$
	-$V^2$인 이유는 V만큼 iteration 수행하면서 최솟값 찾는 과정을 V번 수행해야하기 때문임
	
- 무방향 그래프에서 엣지의 개수는 $O(V^{2})$에 바운드 되기 때문에 최종적으로 $O(|V|^2)$

__발전시키기__
- distance가 가장 가까운 vertex를 찾는 것이고, 그것에 가장 최적화 되어있는 구조는 heap구조임
- distance를 기준으로 노드들을 heap에 넣어놓고 heap을 업데이트 방식
- priority queue(미니멈 힙)에 들어가는 노드의 개수는 V임
- 한번 최소값을 구하고 팝하고 업데이트 하는데 드는 비용 -> lgV(힙의 사이즈가 V이니까)
- 최소값을 찾는데 드는 비용 = $O(|V|lg(|V|))$ -앞에 V는 V번 만큼의 iteration을 수행하는 것, 뒤에는 각 iteration마다 힙을 업데이트 하는 비용
- total => $O(|V|lg(|V|) +|E|lg(|V|))=O(|E|lg(|V|))$ 
- 엣지 개수가 굉장히 많으면 priority queue를 쓰지 않는 경우가 더 효율 적일 수 있음.


## 2. Kruskal\` algorithm