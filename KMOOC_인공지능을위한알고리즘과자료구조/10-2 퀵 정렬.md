# Quick Sort
힙소트 - inplace 소팅 제공
merge sort - 힙소트보다 빠르나, inplace를 제공하지 않아 메모리를 더 많이 잡음

퀵정렬 - 완전한 inplace는 아니나 거의 inplace / 힙소트 보다 속도가 빠름(평균적으로)
![[Pasted image 20221027215148.png]]


- divide and conquer로 접근
	- 퀵정렬에서는 어떤 특정 값(pivot)을 기준으로, 작은 숫자와 큰 숫자로 나눔
	- merge sort에서는 인덱스 mid point 기준으로 나눴음
	- 퀵정렬의 partitioning
	- ![[Pasted image 20221027215346.png]]
	- 44를 기준으로 왼쪽은 44보다 작은 오브젝트, 오른쪽은 큰 오브젝트
	- 44는 sorting이 끝난 후에도 저 위치에 위치하게됨. (44는 정렬이 끝났다.)
	- 퀵정렬에서도 merge sort와 같이 임계값을 두고 그 이하으로는 삽입정렬로 수행해서 재귀적으로 가지 않는 것이 일반적임
	- 베스트 케이스 : 피벗을 잘 골라서 중간 값을 잘 고를 수 있다면 merge sort와 같은 복잡도를 가짐
	- 워스트 케이스 : 가장 작은 것을 피벗으로 고른다면(일반적으로 랜덤으로 고름), $\Theta(n^{2})$
	- ![[Pasted image 20221027215609.png]]
- **퀵정렬의 시간복잡도 정리**
	- 평균 : $\Theta(nlgn)$
	- 워스트 케이스 : $\Theta(n^{2})$
	- 피벗을 어떻게 고르냐에 따라 달라진다.
- worst case를 피하기 위해서는 median 혹은 median에 가까운 것을 고르는 게 좋음. -> 그러나 정렬되지 않은 배열에서 찾기는 상당히 어렵다.
- 그 대안으로 3개, 5개 or 10개 등 정해진 숫자의 성분을 샘플링해서 그 가운데 중간값을 찾는 접근!

__Median of Three__
![[Pasted image 20221027220011.png]]
- 위 처럼 배열의 최좌측, 중앙, 우측(위치기준) 3개를 뽑아서 그 중간값으로 파티션 진행!
- ![[Pasted image 20221027220047.png]]
- 왼쪽에서도 3개 뽑아서 중앙값, 오른쪽에서도 3개뽑아서 중앙값을 피벗으로 각각 가져감

__구현__
![[Pasted image 20221027220137.png]]
- 3개중 중앙값인 57을 기준으로 작은 것은 왼쪽, 큰 것은 오른 쪽에 채움
- ![[Pasted image 20221027220202.png]]
- 그러나, 이렇게 하면 다른 배열이 메모리에 필요함

__inplace에 가깝게 구현하기__
![[Pasted image 20221027220245.png]]
- Median of Three를 수행한 후 가장 작은 값을 제일 왼쪽으로, 큰 값을 중앙으로, pivot인 44는 다른 변수로 저장
- 제일 왼쪽, 제일 오른쪽부터 포인터를 놓고 pair를 찾아가는데, 왼쪽에서부터 찾을 성분은 피벗보다 큰 값, 오른쪽에서부터 찾을 성분은 피벗보다 작은 값, 두 짝을 찾아 swap해준다.
	- 이때, 그 위치가 자신의 자리가 맞는 것들은 스킵함
- 이후에 피벗을 적절한 위치에 넣어야함.

__예제__
1. 배열이 주어지고 6개 이하면 삽입정렬을 수행하도록 threshold값을 지정함
![[Pasted image 20221027220855.png]]
2. median of Three 수행, 피벗을 따로 빼고, 작은값은 왼쪽, 큰 값은 가운데로 이동
![[Pasted image 20221027220953.png]]
3. 왼쪽, 오른쪽 포인터로 잡고 이동하면서 왼쪽은 피벗보다 큰 값, 오른쪽은 피벗보다 작은 값을 찾아가면서 이동 -> 두 값을 교체
![[Pasted image 20221027221037.png]]
4. 다시 포인터 이동하면서 pair찾아서 swap 수행
![[Pasted image 20221027221140.png]]
5. 점점 가운데로 이동하면서 마지막 값끼리 만났을 때, 두 값 사이에 피벗을 넣어줌. (첫번째 partioning 끝)
![[Pasted image 20221027221217.png]]
6. quick sort 함수 호출
	1. 첫번째 피벗은 자기 자리를 찾았기 때문에 그 바로 왼쪽값
	2. median of Three 수행![[Pasted image 20221027221328.png]]
	3. 위와 같이 swap과정 수행
7. 사이즈가 6이하가 되면 insertion sort 수행하기

__메모리 요구량__
- 재귀를 수행하면서, 저장해야하는 값들을 피벗에 저장하고, start, last index들을 저장해야하는데 이를 콜스택에 쌓아놔야함
- 콜스택에 계속 쌓여나가는 과정에서 트리의 높이가 평균적으로 lgn만큼 되기 때문에
- 공간복잡도는 : $\Theta(lg(n))$
- 최악의 경우로 최소값을 피벗으로 선정해가는 경우 메모리 사용량 역시 linear하게 증가함

 
__정렬 알고리즘 복잡도 정리__
![[Pasted image 20221027221658.png]]
