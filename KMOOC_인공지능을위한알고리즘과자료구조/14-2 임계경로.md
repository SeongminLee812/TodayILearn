- Task들의 dependency와 수행하는 시간이 정해져 있을때 DAG에서 크리티컬 패스와 크리티컬 타임을 구하는 알고리즘

- Critical Time : 모든 작업을 병렬적으로 수행하더라도 소요되는 최소한의 시간(모든 작업을 끝내는 가장 빠른 시간)
- Critical Path : Task를 Critical Time에 끝내는 시간

- 정점 태스크 하나하나의 크리티컬 타임을 다 구해서 가장 늦게 끝나는 정점의 크리티컬 타임이 전체 태스크의 크리티컬 타임이 됨
	- dependency 가 없은 태스크는 자기 자신의 태스크 타임이 크리티컬 타임이 되고, 
	- dependency가 있는 태스크는, 앞 크리티컬 타임 + 자신의 태스크타임

- 크리티컬 패스를 구하기 위해서는 previous vertex를 기록해야함
- 또한, in-degree가 0인 정점만 시작할 수 있기 때문에 in-degree도 기록
- Task Time은 입력으로 주어짐
- 위상정렬과 같이 큐를 두고 있음
- ![[Pasted image 20221030162820.png]]

- V가 큐에서 나오기 전에 critical time은 V가 시작될 수 있는 시간을 나타냄
- 큐에서 나오는 순간 V가 실제로 수행되면서 V의 크리티컬 타임은, 크리티컬타임 + 나의 태스크 타임으로 업데이트됨.
- 나를 dependency로 가지는 다른 정점 w에 대해서 W가 자신이 시작할 수 있는 시간과 

__예제__
1. in-degree가 0인 정점들을 큐에 삽입
	1. ![[Pasted image 20221030163226.png]]
2. A가 큐에서 나오면서 크리티컬 타임 업데이트
	1. ![[Pasted image 20221030163244.png]]
3. A를 디펜던시로 가지는 B와 D를 업데이트
	1. B와 D의 in-degree를 줄여주고
	2. in-degree가 0이 된 B를 큐에 넣어주기
	3. previous 태스크 업데이트
	4. ![[Pasted image 20221030163310.png]]
5. F를 큐에서 빼주기
	1. F를 디펜던시로 가지는 C와 E의 정보 업데이트
	2. in-degree 줄여주기
	3. C와 E의 현재 크리티컬 타임과 F의 크리티컬 타임을 비교해서 큰 쪽으로 업데이트 해준다.
	4. F의 크리티컬타임이 더 크다면 previous task를 F로 설정해주고 F의 크리티컬 타임인 17.1로 업데이트함
	5. ![[Pasted image 20221030163358.png]]
	6. ![[Pasted image 20221030163541.png]]
6. 큐에서 B를 꺼냄
	1. ![[Pasted image 20221030163554.png]]
	2. A종료시점에다가 자신의 크리티컬 타임을 더해서 업데이트
	3. ![[Pasted image 20221030163608.png]]
	4. 인접한 CDE에서 in-degree하나씩 빼주기
	5. CDE의 크리티컬 타임이 B의 크리티컬 타임인 11.3보다 작다면 11.3으로 업데이트 해주고, previous태스크를 B로 업데이트 해줌
	6. D 크리티컬 타임 업데이트
	7. ![[Pasted image 20221030163747.png]]
	8. E를 큐에 넣어주기
- 마지막으로 D가 큐에 들어갔다 나오면서 이전 크리티컬 타임과 태스크 타임의 합으로 업데이트되면서 끝남
![[Pasted image 20221030163830.png]]

- 크리티컬 패스 구하기
- D를 기준으로 previous task를 따라가면서 경로를 그림
- ![[Pasted image 20221030163913.png]]
- 