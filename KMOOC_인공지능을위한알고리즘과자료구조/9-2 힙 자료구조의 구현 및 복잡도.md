__perfect binary tree__(포화이진트리) : 이 바이너리 트리의 높이가 h라고 했을 때 모든 leaf 노드가 depth h를 가지고 있어야 하며, leaf 노드를 제외한 모든 노드들은 자녀를 두개씩 가지고 있어야 함.
![[Pasted image 20221027202545.png]]
- binary tree의 높이가 0인 것은 노드가 하나뿐 -> perfect binary tree
- 높이가 0보다 큰 경우 -> 왼쪽 서브트리와 오른쪽 서브트리 모두 perfect binary tree
- petfect binary tree의 노드 개수(높이=h) : $2^{h}-1$
	- 1, 3, 7, 15, 31, 63, 127, 255, 511 ...
- 노드 개수의 제한이 있어 min heap을 만들기 어려움

__Complete Binary Tree__
- perfect binary tree와 유사하나, 어떤 노드 개수던지 정의가 된다.
- 항상 왼쪽부터 오른쪽으로 채워나감.
![[Pasted image 20221027203255.png]]
- 노드를 채워나가는 순서 -> BFS의 순서와 같다
- n개의 노드가 있을 때, complete binary tree의 높이는 lgN에 해당한다
- 
 
__Complete Binary Tree형태를 유지한 채 heap에서 동작하기__
- push
	- 앞선 방법과 같으나 항상 complete tree를 유지하는 위치에 추가하면 됨
	- ![[스크린샷 2022-10-27 20.37.18.png]]
	- 삼투압 현상으로 제자리 찾아감![[스크린샷 2022-10-27 20.37.35.png]]
- pop
	- ![[Pasted image 20221027203816.png]]
	- 기존 방법을 사용한다면 ? 노드가 비어있어서 complete binary tree가 깨짐
	- 따라서 기존 방법을 사용하지 않고 아래 방법을 사용한다.
	- 루트노드를 팝하고 나간 자리에 가장 마지막 leaf노드를 카피한다.
	- ![[Pasted image 20221027203922.png]]
	- 자신의 올바른 위치로 percolation down : 좌우 서브트리 중 더 작은 값과 바꿔서 작은 값을 올림![[Pasted image 20221027203932.png]]

### complete binary tree 힙 구현
- 보통 배열 형태로 나타냄
![[Pasted image 20221027204207.png]]
- BFS order로 순회한 배열을 그림
- 첫번째 인덱스 0은 비워놓고 1부터 채움
![[Pasted image 20221027204218.png]]
- 자신의 인덱스에서 곱하기 2를 하면 왼쪽 자식노드에 접근할 수 있음
- ![[Pasted image 20221027204351.png]]
- 곱하기 2해서 더하기 1을 하면 오른쪽 자식 노드에 접근 가능
- 부모 노드에 접근 : 인덱스 나누기 2 (나머지를 버림)

- __성분 추가하기__
- 힙을 배열로 구현하기 위해서는 현재 몇개의 아이템을 가지고 있는 지 카운팅 해야함
- 카운트 변수에 전체 노드 개수를 답고 있다면, 새로운 아이템은 카운트 +1번위치에 추가해야함
- ![[Pasted image 20221027204646.png]]
- 위와 같은 경우는 min heap 규칙을 지키고 있기 때문에 건들 지 않아도 됨.
- 만약 8을 추가했다면, 13번위치에 추가됨. 13 //2 = 6이므로 6번자리에 있던 23과 비교했을 때 더 작기 때문에 위치를 바꿈
- 부모 노드 3번 인덱스보다도 작기 때문에 promotion으로 위로 올라가게 됨
- ![[Pasted image 20221027204907.png]]

- 시간복잡도 분석
- 탑 오브젝트에 접근 -> 상수시간
- 탑 아이템을 빼내는 것 -> $O(lg(N))$ N은 총 노드 개수
	- 제일 마지막에 있는 leaf노드를 루트노드로 옮기고 percolation down을 함.
	- 이 노드는 다시 leaf 노드로 올 가능성이 굉장히 높음
	- 트리의 높이는 lgN이기 때문에 lgN번 만큼의 비교와 스왑 오퍼레이션 발생
- **push** : 
	- leaf 노드에 푸쉬 후 적절한 위치로 percolation up
	- 루트노드보다 작은 경우 lgN만큼 올라가게 될 것임
	- 만약 가장 큰 아이템이라면 움직이지 않을 것 -> 상수시간
	- 랜덤 값이라고 치면 평균적으로 어떨까 -> 전체 노드가 100개라면 leaf 노드가 50개임. 한 단계만 올라가는 확률을 50%, 그 위로 올라갈 확률은 25%, 한계급 위로 상승할때마다 절반으로 떨어짐.
	- ![[Pasted image 20221027205536.png]]
	- 평균 케이스를 구하기 때문에 n으로 나눠줌
	- h-k는 몇번 percolation up할 것인지(전체 높이 - 노드의 최종 높이)
		- 만약 이 노드가 leaf노드라면 k = h 가 되서 h-h=0이됨. -> percolation 하지 않음
		- $2^k$ 높이 k일 때 존재하는 노드의 개수
		- 위 수식을 풀어보면 결국 상수시간이 나옴
		- 힙에 새로운 아이템을 추가한다 -> 평균적으로는 상수시간에 가능하다.
- 특정 숫자 7이 있는 지 확인 : $O(n)$ linear time
- 가장 큰 아이템 제거 : $O(n)$
- ![[Pasted image 20221027210037.png]]
- 